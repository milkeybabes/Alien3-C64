
****************************************
*	DISK	LOADER		*	
****************************************
DISKZP	EQU	$F0
DSTATUS	EQU	DISKZP	;disk status fori/o
BUFFSB	EQU	DISKZP+1	;buffer for serial Weetabix
COUNTDOWN	EQU	DISKZP+2	;count
TEMP1D	EQU	DISKZP+3	;temp
TEMP2	EQU	DISKZP+4	
C3PO	EQU	DISKZP+5	;flag serial buffer out
ENDPRG	EQU	DISKZP+6	;word address end address
COMMAND	EQU	DISKZP+8

	; LOAD use size of file on disk.
	; interrupts must be disable for load and save
	; DISKADDRESS   = Start Address
	; DISKADDRESS+2 = Length of Data (Save Only)
	; FILENAME      = Length of filename
	; FILENAME+1    = Filename (ASC)

END_LOAD	ORA	#"0"
	STA	CAMEO_BITS+1
	STA	NUMB2+1
	STA	NUMB3+1
	LDY	#0
	JSR	DISK_LOAD	; get all graphic bits
	LDY	#0	; convert plot up nybble colours for screen
	STY	BORDER	; back to black
	STY	MIKE1
	STY	MIKE2
	LDA	#<PSCREEN
	STA	MIKE1+1
	LDA	#<NYBBLE	
	STA	MIKE2+1
	LDA	#4	; four pages
	STA	TEMP
DOIT	LDA	(MIKE1),Y
	TAX
	LDA	EN_SPR_MEM,X	; get colout byte
	STA	(MIKE2),Y
	INY
	BNE	DOIT
	INC	MIKE1+1
	INC	MIKE2+1
	DEC	TEMP
	BNE	DOIT
	RTS

DISK_LOAD	LDA	FILESTL,Y	; Y what block to load in
	STA	MAP_MEM0
	LDA	FILESTH,Y
	STA	MAP_MEM0+1
	LDY	#255	; load single file in
	STY	FILELOOP+1
NEXTFILE	LDX	#0
FILELOOP	LDY	#0	; load next file
GETNAME	INY
	LDA	(MAP_MEM0),Y
	BEQ	SETNAME1
	STA	FILENAME,X
	INX
	CMP	#255
	BNE	GETNAME
	RTS		; exit loader

SETNAME1	STX	FILE_LENGTH	; length of file to load
	INY
	LDA	(MAP_MEM0),Y
	STA	ENDPRG
	INY
	LDA	(MAP_MEM0),Y
	STA	ENDPRG+1
	STY	FILELOOP+1
	JSR	FILELOAD	; now load it ok
	JMP	NEXTFILE

FILENAME	DB	2	; number of letters in file name
	DS	12,0	; actual filename

FILESTL	DL	CAMEO_BITS,LEVEL_LOAD
FILESTH	DH	CAMEO_BITS,LEVEL_LOAD

LEVEL_LOAD	DB	"MOCK0",0
	DW	CHARSET
	DB	255

CAMEO_BITS	DB	"C0",0	; charset
	DW	TCHARSET
NUMB2	DB	"S0",0
	DW	PSCREEN
NUMB3	DB	"N0",0	; nybble colours
	DW	EN_SPR_MEM	; bang in where enemy pointers are copyied to
	DB	255

FILELOAD	LDA	#0
	STA	DSTATUS
	STA	C3PO
	TAX
	LDA	#$60
	STA	COMMAND	
	JSR	SENDSA
	LDA	#8	
	JSR	SENDTALK	
	LDA	COMMAND
	JSR	SENDTALKSA
	JSR	RECEIVESERIAL
	LDA	DSTATUS
	LSR	A
	LSR	A
	BCS	RETURN	; error
	JSR	RECEIVESERIAL
L13	LDA	#$FD
	AND	DSTATUS
	STA	DSTATUS
	JSR	RECEIVESERIAL
	TAX
	LDA	DSTATUS
	LSR	A
	LSR	A
	BCS	L13	
	TXA
	LDY	#0
	LDX	#$30	;RAM
	STX	1
	STA	(ENDPRG),Y
	LDX	#$0D	;IO
	STX	1
SK21	INC	ENDPRG	
	BNE	SK23		
	INC	ENDPRG+1
SK23	LDA	BORDER
	EOR	#1
	STA	BORDER
	BIT	DSTATUS
	BVC	L13
	JSR	SENDUNTALK	
	LDA	#8	; LIGHT OFF!
	JSR	SENDT+1
	LDA	COMMAND
	AND	#$EF
	ORA	#$E0
	JSR	SENDLISTENSA
	JSR	SENDUNTALK
RETURN	LDA	DSTATUS
	RTS

STATOR	ORA	DSTATUS
	STA	DSTATUS
	RTS

SENDSA	LDA	COMMAND
	BMI	RETURN	
	LDY	#1
	LDA	#0
	STA	DSTATUS
	LDA	#8
	JSR	SENDT2
	LDA	COMMAND
	ORA	#$F0
	JSR	SENDLISTENSA
	LDA	DSTATUS	
	BPL	SK10	
	PLA
	PLA		; return address
	JMP	RETURN	; should be error message	
SK10	LDY	#0
GH	LDA	FILENAME,Y
	JSR	SENDSERDEF
	INY
	CPY	#255		; modify
FILE_LENGTH	EQU	*-1
	BCC	GH
SK11	JSR	SENDUNLISTEN-5
	CLC
	RTS

SENDTALK	ORA	#&40
SENDT	NOW
SENDT2	ORA	#&20
SENDLISTEN	PHA
	BIT	C3PO
	BPL	SK1
	SEC
	ROR	TEMP1D
	JSR	SENDSERIAL
	LSR	C3PO
	LSR	TEMP1D
SK1	PLA
	STA	BUFFSB
	JSR	SERIAL1
	CMP	#$3F
	BNE	SK2
	JSR	CLOCKON
SK2	LDA	$DD00
	ORA	#8
	STA	$DD00
SE1	JSR	CLOCKOFF
	JSR	SERIAL1
	JSR	DELONEMS
SENDSERIAL	JSR	SERIAL1
	JSR	GETSIN
	BCS	TOUT1
	JSR	CLOCKON
	BIT	TEMP1D
	BPL	SK3
L01	JSR	GETSIN	
	BCC	L01	
L02	JSR	GETSIN
	BCS	L02
SK3	JSR	GETSIN
	BCC	SK3
	JSR	CLOCKOFF

	LDA	#8
	STA	COUNTDOWN
L03	LDA	$DD00
	CMP	$DD00
	BNE	L03
	ASL	A
	BCC	KB1+1
	ROR	BUFFSB
	BCS	SK4
	JSR	SERIAL0
	BNE	SK5
SK4	JSR	SERIAL1
SK5	JSR	CLOCKON
	NOP
	NOP
	NOP
	NOP
	LDA	$DD00
	AND	#$DF
	ORA	#$10
	STA	$DD00
	DEC	COUNTDOWN
	BNE	L03

	LDA	#4
	STA	$DC07
	LDA	#$19
	STA	$DC0F
	LDA	$DC0D
L04	LDA	$DC0D
	AND	#2
	BNE	KB1+1
	JSR	GETSIN
	BCS	L04
	RTS	

TOUT1	LDA	#$80
KB1	BIT	$3A9
SERTIMEOUT	JSR	STATOR
	CLC
	BCC	SENDUNLISTEN
SENDLISTENSA	STA	BUFFSB
	JSR	SE1	; see send listen
	
CLEARATN	LDA	$DD00
	AND	#$F7
	STA	$DD00	
	RTS

SENDTALKSA	STA	BUFFSB
	JSR	SE1
WAITCLOCK	JSR	SERIAL0
	JSR	CLEARATN
	JSR	CLOCKON
WC1	JSR	GETSIN
	BMI	WC1
	RTS

SENDSERDEF	BIT	C3PO
	BMI	SDF1
	SEC
	ROR	C3PO
	BNE	SDF2
SDF1	PHA
	JSR	SENDSERIAL				
	PLA
SDF2	STA	BUFFSB
	CLC
	RTS

SENDUNTALK	JSR	CLOCKOFF
	LDA	$DD00
	ORA	#8
	STA	$DD00
	LDA	#$5F
KB2	BIT	$3FA9
	JSR	SENDLISTEN
SENDUNLISTEN	JSR	CLEARATN
	TXA
	LDX	#$0A
L05	DEX
	BNE	L05
	TAX
	JSR	CLOCKON
	JMP	SERIAL1

RECEIVESERIAL	LDA	#0
	STA	COUNTDOWN
	JSR	CLOCKON
L06	JSR	GETSIN
	BPL	L06
L08	LDA	#01
	STA	$DC07
	LDA	#$19                	
	STA	$DC0F
	JSR	SERIAL1
	LDA	$DC0D
L07	LDA	$DC0D	
	AND	#2
	BNE	SK6
	JSR	GETSIN
	BMI	L07	
	BPL	SK7
SK6	LDA	COUNTDOWN	
	BEQ	SK8
	LDA	#2
	JMP	SERTIMEOUT	

SK8	JSR	SERIAL0
	JSR	CLOCKON
	LDA	#$40
	JSR	STATOR
	INC	COUNTDOWN
	BNE	L08

SK7	LDA	#8
	STA	COUNTDOWN
L09	LDA	$DD00
	CMP	$DD00
	BNE	L09
	ASL	A
	BPL	L09
	ROR	TEMP2
L10	LDA	$DD00
	CMP	$DD00
	BNE	L10
	ASL	A
	BMI	L10
	DEC	COUNTDOWN
	BNE	L09

	JSR	SERIAL0
	BIT	DSTATUS
	BVC	SK9
	JSR	SENDUNLISTEN+3
SK9	LDA	TEMP2
	CLC
	RTS

GETSIN	LDA	$DD00
	CMP	$DD00
	BNE	GETSIN
	ASL	A
	RTS

CLOCKON	LDA	$DD00
	AND	#$EF
	STA	$DD00
	RTS

CLOCKOFF	LDA	$DD00
	ORA	#$10
	STA	$DD00
	RTS

DELONEMS	TXA		; save old command
	LDX	#$B8
DEL1MS	DEX
	BNE	DEL1MS
	TAX
	RTS

SERIAL1	LDA	$DD00
	AND	#$DF	; '1' to serial
	STA	$DD00
	RTS

SERIAL0	LDA	$DD00
	ORA	#$20
	STA	$DD00
	RTS

****************************************
*	UNPACK COMPRESSED DATA
****************************************

;UnPack
	;ORG	&6E80
PA_START

	;ORG	&9100	; save data to
PA_SAVE	;INCBIN	D:\C64\LEVEL1.DAT


	;ORG	&C000

MEMORY	EQU	&FC
STORE	EQU	&FE

	; Unpack Compressed Data
UNPACK	LDA	#<PA_START
	STA	MEMORY+1	; high
	LDA	#>PA_START
	STA	MEMORY+0	; low
	LDA	#<PA_SAVE
	STA	STORE+1	; high
	LDA	#>PA_SAVE
	STA	STORE+0	; low
	LDY	#0
UN_CRUNCH	LDA	(STORE),Y	; first byte
	BNE	ALL_GO	; 0 end of data
	RTS		; exit

ALL_GO	BMI	SPECIALS
	TAX		; amount of none repeat bytes
	JSR	BUMP_STORE	; advance on store
UN_LOOP	LDA	(STORE),Y
	STA	(MEMORY),Y
	JSR	BUMP_STORE	; advance pack memory
	JSR	BUMP_MEMORY	; advance store
	DEX
	BPL	UN_LOOP	; all of it
	JMP	UN_CRUNCH	; all data	

SPECIALS	AND	#%01111111	; get amount of duplicates
	TAX		; amount
	JSR	BUMP_STORE	; advance on store
	LDA	(STORE),Y	; get byte that is repeated
	STA	STORES+1	; live!
	JSR	BUMP_STORE	; past last byte
STORES	LDA	#255	; this byte
	STA	(MEMORY),Y	; save out
	JSR	BUMP_MEMORY	; advance
	DEX
	BNE	STORES	; all repeats
	JMP	UN_CRUNCH	; all data

	; Advance one on Pack store
BUMP_STORE	INC	STORE	; low + 1
	BNE	!NO_CARRY	; overflow 
	INC	STORE+1	; high + 1
!NO_CARRY	RTS

	; Advance one on Memory store
BUMP_MEMORY
	INC	MEMORY	; low + 1
	BNE	!NO_CARRY	; overflow 
	INC	MEMORY+1	; high + 1
!NO_CARRY	RTS


	FREE	TILE_MAP-*	; free code memory


	SEND	COMPUTER1
	END	START_CODE

